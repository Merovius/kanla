#!/usr/bin/env perl
# vim:ts=4:sw=4:expandtab

use strict;
use warnings;
use v5.10;
# libanyevent-xmpp-perl
use AnyEvent::XMPP::Client;
use AnyEvent::XMPP::Ext::Disco;
use AnyEvent::XMPP::Ext::Ping;
use AnyEvent::XMPP::Ext::VCard;
use AnyEvent::XMPP::Ext::Version;
# libanyevent-perl
use AnyEvent;
use AnyEvent::Util;
use AnyEvent::Handle;
# libjson-xs-perl
use JSON::XS;
# core
use Carp;
use Data::Dumper;
use File::Basename qw(basename);

# TODO: config + multi-account support

my @destination_accounts = qw(
    michael@stapelberg.de
);

# Messages which were produced while no XMPP connection was established (yet).
# They will be sent when a connection is established.
my @queued_messages;
# An AnyEvent->timer which will send @queued_messages. We need that because we
# need to wait for presence updates to finish before we can determine an
# inidividual user’s presence with the highest priority. While it would be
# easier to send to a bare JID, we also need full JIDs for message receipts.
my $queued_timer;

my $xmpp = AnyEvent::XMPP::Client->new();
$xmpp->add_account(
    'zkj-monitor@jabber.ccc.de',
    'geheim',
    undef,
    undef,
    { initial_presence => undef });

my $ping = AnyEvent::XMPP::Ext::Ping->new();
$xmpp->add_extension($ping);
# Sends a ping request every 60 seconds. If the server does not respond within
# another 60 seconds, reconnect.
$ping->auto_timeout(60);

# We are a good jabber citizen and mark this client as a bot.
my $disco = AnyEvent::XMPP::Ext::Disco->new();
$xmpp->add_extension($disco);
$disco->set_identity('client', 'bot');

# Advertise VCard support for a nice real name plus an avatar later.
my $vcard = AnyEvent::XMPP::Ext::VCard->new();
$disco->enable_feature($vcard->disco_feature);

my $version = AnyEvent::XMPP::Ext::Version->new();
$version->set_name("zkj-monitor");
$version->set_version("0.1");
$version->set_os("Linux");
$xmpp->add_extension($version);
$disco->enable_feature($version->disco_feature);

$xmpp->set_presence(undef, 'okay (17:32:00, 2012-10-09)', 11);

$xmpp->reg_cb(
    stream_ready => sub {
        my ($cl, $account) = @_;
        $vcard->hook_on($account->connection(), 1);
    },

	connected => sub {
        my ($self, $account) = @_;
        say "connected, adding contacts";

        # TODO: vcard avatar should be our logo as soon as we got one :)
        $vcard->store($account->connection(), {
                NICKNAME => 'zkj-monitor',
                FN => 'zkj-monitor',
            }, sub {
                my ($error) = @_;
                if ($error) {
                    say "[XMPP] VCard upload failed: " . $error->string;
                }
            });

        for my $jid (@destination_accounts) {
            $account->connection()->get_roster()->new_contact($jid, undef, undef,
                sub {
                    my ($contact, $err) = @_;
                    if (defined($contact)) {
                        say "Added $jid, sending presence subscription";
                        $contact->send_subscribe();
                    } else {
                        say "Error adding $jid: $err";
                    }
                });
        }

    },

    presence_update => sub {
        my ($cl, $account, $roster, $contact, $old_presence, $new_presence) = @_;

        return if defined($queued_timer);
        $queued_timer = AnyEvent->timer(
            # We wait 5 seconds for the presence updates to trickle in. On very
            # slow uplinks, that might be too short, but then again, monitoring
            # will likely not work very well anyways in that situation.
            after => 5,
            cb => sub {
                for my $msg (@queued_messages) {
                    xmpp_msg_all($account, $msg);
                }
                undef $queued_timer;
            });
    },

    contact_request_subscribe => sub {
        my ($cl, $acc, $roster, $contact) = @_;
        # Ignore subscription requests from people who are not in
        # @destination_accounts.
        return unless ($contact->jid ~~ @destination_accounts);

        # Acknowledge everything else.
        say "Acknowledging subscription request from " . $contact->jid;
        $contact->send_subscribed;
        $contact->send_subscribe;
    },

    disconnect => sub {
        my ($self, $account, $host, $port, $message) = @_;
        say "[XMPP] Disconnected: $message";

        # Try to reconnect, if necessary.
        $xmpp->update_connections();
    },

    error => sub {
        my ($self, $account, $error) = @_;
        say "[XMPP] Error: " . $error->string();

        # Try to reconnect, if necessary.
        $xmpp->update_connections();
    },
);
$xmpp->start;

sub xmpp_msg_all {
    my ($account, $message) = @_;

    for my $dest (@destination_accounts) {
        my $presence = $xmpp->get_priority_presence_for_jid($dest);
        if (!defined($presence)) {
            say "[XMPP] No presence found for $dest, skipping";
            next;
        }

        # NB: We cannot use $xmpp->send_message here because
        # that will make the JID a bare JID and use its own
        # conversation tracking technique.
        $account->connection->send_message(
            $presence->jid,
            'chat',
            undef,
            body => $message);
    }
}

sub handle_stderr_msg {
    my ($module, $data) = @_;
    if (!exists($data->{severity}) ||
        !exists($data->{message})) {
        say STDERR "Malformed JSON output from module $module (missing severity or messages property).";
        return;
    }

    if ($data->{severity} eq 'critical') {
        say "relaying: " . $data->{message};
        my $acc = $xmpp->find_account_for_dest_jid($destination_accounts[0]);
        if (!defined($acc)) {
            push @queued_messages, $data->{message};
            return;
        }
        xmpp_msg_all($acc, $data->{message});
    }
}

# Now start all the monitoring modules, read their stderr and relay that errors
# to XMPP.
for my $module (<modules/*>) {
    if (! -e $module) {
        say STDERR "Skipping non-executable module $module";
        next;
    }

    my ($pr, $pw) = AnyEvent::Util::portable_pipe;
    fcntl($pr, AnyEvent::F_SETFD, AnyEvent::FD_CLOEXEC);
    my $w;
    $w = AnyEvent::Handle->new(
        fh => $pr,
        on_error => sub {
            my ($hdl, $fatal, $msg) = @_;
            say "Error reading from child proc: $msg";
# TODO: restart the module so that one can just kill a module to make it pick
# up code changes. use a timeout of 2 seconds so that you don’t get spammed
# with failure messages in case your module exit 1;s.
            $w->destroy;
        });

    my @start_request; @start_request = (json => sub {
        my ($hdl, $hashref) = @_;
        handle_stderr_msg(basename($module), $hashref);
        $hdl->push_read(@start_request);
    });

    $w->push_read(@start_request);

    my $cv = run_cmd [ $module ],
        # stdout goes to /dev/null for now.
        '>', '/dev/null',
        '2>', $pw;
}

# Run forever.
AnyEvent->condvar->recv;
