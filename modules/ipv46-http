#!/usr/bin/env perl
# vim:ts=4:sw=4:expandtab

use strict;
use warnings;
use v5.10;
# libanyevent-http-perl
use AnyEvent::HTTP;
# libanyevent-perl
use AnyEvent::Socket;
# libjson-xs-perl
use JSON::XS;
# core
use Socket qw(SOCK_STREAM);
use Carp;
use Data::Dumper;
# libsocket-getaddrinfo-perl
use Socket::GetAddrInfo qw(getaddrinfo getnameinfo :constants);
# liburi-perl
use URI;

# TODO: config
my $url = "http://www.i3wm.org";
my $interval = 60;

# Disable buffering.
$| = 1;

sub signal_error {
    my ($severity, $message) = @_;
    say STDERR encode_json({
        severity => $severity,
        message => $message
    });
}

# Periodically run the check, but donâ€™t wait for the first $interval seconds to
# pass, but run it right now, too.
my $main_timer;
$main_timer = AnyEvent->timer(
    after => 0,
    interval => $interval,
    cb => sub {
        # XXX: We re-resolve all the time because it is assumed that you are
        # using a local caching nameserver, which is a good idea anyways and
        # allows us to correctly pick up new addresses once the old ones
        # expire.

        # Since AnyEvent::HTTP offers no way to specify whether we want to
        # access the website via IPv4 or IPv6, we need to resolve the hostname
        # on our own and specifically connect to the resolved IP address.
        my $host = URI->new($url)->host;
        my %hints = (socktype => SOCK_STREAM);
        my ($err, @res) = getaddrinfo($host, 'www', \%hints);
        if ($err) {
            signal_error('critical', "getaddrinfo($host): $err");
            return;
        }

        for my $ai (@res) {
            my ($err, $ip) = getnameinfo($ai->{addr}, NI_NUMERICHOST);
            if ($err) {
                signal_error('critical', "getnameinfo(ai->addr): $err");
                next;
            }
            http_get $url,
                # This timeout of 10s is for each individual stage, e.g. for
                # connecting, for waiting for a response, etc. It is not a
                # global timeout.
                timeout => 10,
                headers => {
                    'User-Agent' => 'zkj-monitor',
                },
                tcp_connect => sub {
                    my (undef, $port, $connect_cb, $prepare_cb) = @_;
                    # Wrap around tcp_connect, replacing the host with our resolved one.
                    AnyEvent::Socket::tcp_connect($ip, $port, $connect_cb, $prepare_cb);
                },
                sub {
                    my ($body, $hdr) = @_;
                    if ($hdr->{Status} !~ /^2/) {
                        signal_error('critical', 'HTTP reply ' . $hdr->{Status} . " for $url ($ip)");
                        return;
                    }
                    if ($body !~ /Download the latest version/) {
                        signal_error('critical', "HTTP body of $url ($ip) does not match template");
                        return;
                    }
                };
        }
    });

# Run forever.
AnyEvent->condvar->recv;
