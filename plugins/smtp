#!/usr/bin/env perl
# vim:ts=4:sw=4:expandtab

use strict;
use warnings;
use utf8;
use v5.10;

# libanyevent-perl
use AnyEvent;
use AnyEvent::Handle;
use AnyEvent::Socket;

# libjson-xs-perl
use JSON::XS;

# libconfig-general-perl
use Config::General;

# core
use Carp;
use Data::Dumper;
use IO::Handle;
use Socket qw(SOCK_STREAM);

my $errorfh = IO::Handle->new_from_fd(3, 'w');
$errorfh->autoflush(1);

# reads in the whole STDIN
sub slurp {
    local $/;
    <STDIN>;
}

my $config_str = slurp();
say "config = *$config_str*";

my $conf = Config::General->new(
    -String => $config_str,

    # open all files in utf-8 mode
    -UTF8 => 1,

    # normalize yes, on, 1, true and no, off, 0, false to 1 resp. 0
    -AutoTrue => 1,

    # case-insensitive key names by lowercasing everything
    -LowerCaseNames => 1,

    # provide the ->array, ->hash, etc. methods
    -ExtendedAccess => 1,

    # we need to merge duplicate options,
    # otherwise the default config
    # will not get overwritten,
    # but amended.
    -MergeDuplicateOptions => 1,
    -FlagBits              => {
        family => {
            ipv4 => 1,
            ipv6 => 1,
        },
    },
    -DefaultConfig => <<'EOT'
family = ipv4 | ipv6
EOT
);

# TODO: support multiple hosts
my $host     = $conf->value('host');
my $timeout  = ($conf->exists('timeout') ? $conf->value('timeout') : 10);
my $interval = 60;

# Ensure timeout is an int and > 0.
$timeout += 0;
$timeout ||= 1;

# Disable buffering.
$| = 1;

sub signal_error {
    my ($severity, $message) = @_;
    say $errorfh encode_json({
            severity => $severity,
            message  => $message
    });
}

sub verify_availability {
    my ($ip, $service) = @_;
    tcp_connect $ip, $service, sub {
        my ($fh) = @_;
        if (!$fh) {
            signal_error(
                'critical',
                "Connecting to $ip on port $service failed: $!"
            );
            return;
        }

        my $t;
        $t = AnyEvent->timer(
            after => $timeout,
            cb    => sub {
                signal_error(
                    'critical',
"Timeout ($timeout s) waiting for SMTP greeting on [$ip]:$service"
                );
                undef $t;
            });

        my $handle;    # avoid direct assignment so on_eof has it in scope.
        $handle = AnyEvent::Handle->new(
            fh       => $fh,
            on_error => sub {
                signal_error(
                    'critical',
                    "TCP read error on [$ip]:$service: " . $_[2]);
                undef $t;
                $_[0]->destroy;
            },
            on_eof => sub {
                $handle->destroy;    # destroy handle
                signal_error(
                    'critical',
                    "TCP EOF on [$ip]:$service"
                );
                undef $t;
            });

        $handle->push_read(
            line => sub {
                my ($handle, $line) = @_;

                # cancel timeout
                undef $t;

                if ($line =~ /^220 /) {

                    # SMTP greeting received,
                    # everything fine.
                    # Close the connection.
                    $handle->push_write("QUIT\r\n");
                    $handle->on_drain(
                        sub {
                            shutdown $fh, 1;
                            $handle->destroy;
                            undef $handle;
                        });
                    return;
                }

                # Wrong greeting received.
                my $ellipsized = substr($line, 0, 5);
                $ellipsized .= "…" if length($line) > 5;
                signal_error(
                    'critical',
"Protocol error on [$ip]:$service: Wrong greeting received. Expected '220 …', got '$ellipsized'"
                );
            });
    };
}

# Called by AnyEvent::Socket’s resolve_sockaddr.
sub resolved {
    my $host = shift;

    # family is either A or AAAA
    my $family = shift;
    if (@_ == 0) {
        signal_error('critical', "Cannot resolve $host ($family) DNS record");
        return;
    }
    for my $record (@_) {
        my ($service, $host) = AnyEvent::Socket::unpack_sockaddr($record->[3]);
        verify_availability(format_address($host), $service);
    }
}

# Periodically run the check, but don’t wait for the first $interval seconds to
# pass, but run it right now, too.
my $main_timer;
$main_timer = AnyEvent->timer(
    after    => 0,
    interval => $interval,
    cb       => sub {

        # XXX: We re-resolve all the time because it is assumed that you are
        # using a local caching nameserver, which is a good idea anyways and
        # allows us to correctly pick up new addresses once the old ones
        # expire.

        my ($host, $service) = parse_hostport $host, "smtp";

        if ($conf->obj('family')->value('ipv4')) {
            AnyEvent::Socket::resolve_sockaddr(
                $host, $service, "tcp", 4, SOCK_STREAM,
                sub { resolved($host, 'A', @_) });
        }
        if ($conf->obj('family')->value('ipv6')) {
            AnyEvent::Socket::resolve_sockaddr(
                $host, $service, "tcp", 6, SOCK_STREAM,
                sub { resolved($host, 'AAAA', @_) });
        }
    });

# Run forever.
AnyEvent->condvar->recv;
